Nous pouvons distinguer trois grand axes de cause de problèmes:
-La gestion de l’exécution du code
-La définition d’une grammaire et des lexèmes associés
-Tout les petits soucis lié à PLY

=> Gestion de l’exécution du code :
Cette problématique et la solution finale que nous lui avons apportée est décrite dans la partie explicative du FOR et du IF. Notons tout de même qu’il a été question de la gérer via un arbre d’exécution, en se basant sur la notion d’abstract syntax tree (pour laquelle python3 fournit d’ailleurs une implémentation). L’idée était de créer un arbre petit à petit lors de l’analyse syntaxique et, une foi cette dernière terminée, parcourir cet arbre pour exécuter le code tout en étant affranchit de toute notion d’analyse syntaxique (ou plutôt, les reléguant à python). Nous pensons toujours que l’idée est bonne mais son implémentation s’est avérée plus compliquée que prévue. 
Nous avons finalement caché la notion d’arbre. Les éléments constitutifs de l’arbre devenant les ExecNode de notre solution finale, circulant désormais de manière plus fluide durant l’analyse syntaxique, avec donc un juste milieu entre « Ne rien exécuter durant l’analyse syntaxique et tout faire après » et « Tout exécuter étape par étape durant l’analyse syntaxique »

=> Définition d’une grammaire et des lexèmes associés :
La séparation des lexèmes en trois états (INITIAL, BLOCK et STRING) a rendu assez facile l’implémentation de la grammaire de base demandée. 
Les fonctionnalités supplémentaires, introduites dans la partie «Cahier de charge» de l’énoncé du projet ont, elles, demandées quelques redéfinitions et réflexions. Le point clé fut d’orchestrer ces changements autour de la redéfinition de string_expression en value_expression, ajoutant sous ce terme les nouveaux types (integer et boolean), ces nouveaux types pouvant être définit via eux même ou via value_expression (comme avec « integer -> value_expression INT_OP value_expression », qui englobe d’ailleurs « integer -> integer INT_OP integer »). Cela permettait de ne rien modifier à la notion de « variable » et d’ « expression », comme nous l’avions considéré dans un premier temps.

=> Les soucis lié à PLY :
Nous avons rencontré de très (TRÈS) nombreuses difficultés avec l’utilisation de PLY. Bien que probablement intrinsèquement pas si compliquée, le fait que cette bibliothèque redéfinissent python (et donc, amène en quelque sorte un nouveau langage de programmation) plutôt que de simplement lui amener de nouvelles fonctions a été sources de nombreuses incompréhensions. Mais il s’agit d’une multitude de petits problèmes et il ne serrait pas pertinent de les passer en revue. Et cela ne comporte rien que des recherches sur le net n’a pu résoudre.
